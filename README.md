# 操作系统

教材：汤小丹  计算机操作系统（第四版）

## 第一章 操作系统引论

#### 操作系统作用

1.OS作为用户和计算机硬件之间的接口

2.OS作为计算机系统资源的管理者

3.OS实现了对计算机资源的抽象

#### 操作系统的演进

由单道批处理系统演进为多道批处理系统：

前者是一个一个连续处理任务，内存中只保持一道作业，系统的资源得不到充分的利用，在系统进行I/O请求的时候CPU处于等待状态，由于I/O系统的低速性更使得CPU的利用率显著降低；

后者将提交的作业存放在外存中，组成一个“后备队列”，由作业调度程序按照一定的算法从中选择若干个作业调入内存，使它们共享CPU和系统资源，多道程序交替运行使得CPU处于忙碌状态。在A程序I/O的CPU空挡时间，可以调度B运行。

####  操作系统的基本特性

1.并发：正是由于程序可以并发执行，才使得OS能有效增加系统吞吐量

​	区别两个概念，并发和并行：并发是说在一段时间内宏观上有多个程序在同时运行，而微观下程序只能分时交替运行；并行是说多个事件在同一时刻发生。

2.共享：在OS环境下的资源共享成为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。资源共享分为互斥共享方式和同时访问方式。

3.虚拟：在OS中 通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能成为“虚拟”。这种技术有时分复用和空分复用，时分复用的例子是多道程序并发执行，瓜分时间片；空分复用的例子有信道的频段划分。

## 第二章 进程的描述和控制

**进程的定义**：进程控制块（Process Control Block, PCB)是为进程设计的一个数据结构，用来描述进程的基本情况和活动过程。由程序段，相关的数据段和PCB三部分就构成进程的实体，简称进程。

#### 进程的基本状态和转换

1.就绪状态：指进程已经处于准备好运行的状态，已分配到除CPU以外的必要资源。只需要获得CPU即可运行。

2.执行状态：正在执行

3.阻塞状态：正在执行的进程由于发生了诸如I/O请求，申请缓冲区失败等事件，暂时无法继续执行时的状态。

4.创建状态：创建一个进程有若干步骤，（1）申请一个空白的PCB并填入控制信息（2）分配运行时的资源（3）将该进程转入就绪状态并插入就绪队列中。完成创建的过程就是创建状态。

5.终止状态：将PCB清零归还系统。

6.**挂起操作**和进程状态的转换：如果进程正在执行，挂起之后将暂停执行；若原本处于就绪状态则该进程此时暂不接受调度。与挂起操作相对应的操作时激活（Suspend/Active）。活动就绪-->静止就绪  活动阻塞-->静止阻塞  静止就绪是不会被调度执行的。



#### 进程控制块PCB的作用

1.是进程存在于系统的唯一标识。

2.保护进程的CPU现场信息：当进程因阻塞而停止运行时，必须保留自己的现场信息，以供再度调用时恢复。

3.提供进程管理所需要的信息：记录了程序和数据的内外存地址，维护了进程所需资源的清单。

4.PCB还维护了进程处于何种状态，即就绪，运行，阻塞这些进程状态；还保存有进程优先级，等待时间，已执行时间等调度算法需要用到的数据。

5.实现与其他进程的同步与通信，PCB具有用于实现进程通信的区域。

**PCB记录的信息**：进程标识符；处理机状态；进程调度信息；进程控制信息

1.唯一地标识一个进程

2.处理机的上下文，主要是寄存器状态：通用寄存器；指令计数器；程序状态字PSW；用户栈指针

3.进程状态；进程优先级；进程调度所需信息

4.程序和数据的地址；进程同步和通信机制；资源清单；链接下一个PCB的指针

#### 进程控制

操作系统内核：与硬件紧密相关的模块，常用的驱动程序以及运行频率较高的模块，它们被安排在紧靠硬件的软件层次中，常驻内存，通常被称为OS内核。

##### <u>内核态和用户态</u>：

内核态具有较高的权限，能执行一切指令，访问所有的寄存器和存储区；用户态仅能执行规定的指令，访问指定的寄存器和存储区。



#### 进程同步

##### 信号量机制

这是一种卓有成效的进程同步工具。

1. **整型信号量**：定义为一个用于表示资源数目的整型量S，仅能通过两个标准的原子操作来访问，wait(S)/signal(S)

这两个操作被称为**P，V操作**。原子操作不可中断。

```
wait(S){
	while(S<=0);//忙等
	S--;
}
signal(S){
	S++;
}
```

wait操作中，只要S<=0，就会不断测试，不遵循“让权等待”，忙等。

2. **记录型信号量**

```C
typedef struct{
    int value;
    struct process_control_block *list;
}semaphore;

wait(semaphore *S){
    S->value--;//可分配的该类资源减少1个
    if(S->value<0) block(S->list);//该进程自我阻塞
}

signal(semaphore *S){
    S->value++;//资源数目加1
    if(S->value<=0){
        wakeup(S->list);//仍有等待该资源的进程被阻塞，唤醒阻塞队列的第一个等待的进程
    }
}
```

3. **AND型信号量**

   一个进程需要获得两个或者多个共享资源后方能执行任务，容易形成进程死锁。AND同步机制的基本思想是要么资源全部分配给进程，要么一个都不分配，这样可以避免死锁。

   **哲学家进餐问题**的解决就可以用AND信号量：仅当哲学家的左右两只筷子都可用时，才允许他拿起筷子进餐。

   ```C
   Semaphore chopstick[]={1,1,1,1,1};
   do{
   	Swait(chopstick[(i+1)%5], chopstick[i]);
   	Ssignal(chopstick[(i+1)%5],chopstick[i]);
   }while(true)
   ```

   

4. **信号量集**

   可以一次申请/释放多个信号量。

**信号量的应用**

1.利用信号量实现进程互斥。

​		将某临界资源设置一互斥信号量mutex，**各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)操作中间即可**。这一对互斥信号量就相当于锁。

2.利用信号量实现前驱关系。

​		P1-->P2  希望P1中的S1语句结束之后再执行P2中的S2语句。

​		使两个进程共享一个公用的信号量S，在P1中 signal(S) ; 在P2中 wait(S)

##### 管程

​		可以利用共享数据结构抽象地表示系统中的共享资源，并且将对该共享资源的操作定义为一种过程。代表共享资源的数据结构和上述过程组成的资源管理程序共同构成了一个操作系统的资源管理模块，我们称之为管程。

​		管程由四部分组成 : 管程的**名称**；局部于管程的**共享数据结构**说明；对该数据结构进行**操作**的一组过程；对局部于管程的共享数据设置**初始值**的语句。

​		进程要访问临界资源时，都只能通过管程间接访问，而管程每次只准许一个进程进入管程，从而实现进程互斥。

​		管程的同步工具：如同步操作原语wait和signal

```C
//管程封装生产者消费者活动
Monitor Producer_Consumer{
    item[] buffer;
    int in, out;
    condition notFull, notEmpty;
    //定义函数
    void put(Item it){
        
    }
    void get(Item it){
        
    }
}
//生产者消费者问题
void Producer{
    new Item it;
    PC.put(it);
}
void Consumer{
    Item it = PC.get();
}
```

#### 进程通信

进程之间要传递大量数据时，可以利用OS提供的高级通信工具。高级通信机制分为四大类：共享存储器系统， 管道通信系统，消息传递系统，客户端-服务器系统。

1.共享存储器：在内存中划出一块共享存储区域，进程之间可以通过该区域交换信息。

2.管道通信：连接一个读进程和写进程，又称pipe文件。写进程以字符流形式将数据送入管道，接受方拿数据。

3.消息传递：将通信数据封装成消息，利用操作系统提供的通信命令在进程间完成消息传递。计算机网络就是这么干的，将消息称为报文。

4.客户机-服务器：（1）套接字：基于网络型的不说了，还有基于文件型的，套接字关联一个文件，通过读写文件实现通信（2）远程调用：远程过程调用RPC：这个有点像计网的web服务器中的应用调用。

## 第三章 处理机调度与死锁

#### 处理机作业调度

CPU利用率；对诸进程的公平性；I/O，计算任务的平衡性；作业的平均周转时间；

系统吞吐量高（吞吐量指在单位时间内系统所完成的作业数）；响应时间快；截止时间的保证…

**作业控制块**（Job Control Block **JCB**）：为了管理和调度作业，给每个作业设置了一个标志，有作业类型，作业状态，调度信息，资源需求，资源使用状态等信息。

**作业调度**：根据JCB的信息，设计一定的算法，选取哪些作业调入内存，并为它们创建进程，分配必要的资源。然后将新创建的进程-排在就绪队列上等待调度，因此也把作业调度成为接纳调度。每次执行作业调度时，都需要做出两个决定：接纳多少作业？接纳哪些作业？

##### 先来先服务（FCFS）和短作业优先（SJF）

1.每次从就绪队列中选择一个最先进队列的进程，为之分配处理机。该进程一直运行到完成或发生某事件而阻塞之后，进程调度程序才将处理机分配给其他进程。可按进程优先级设置多个队列，每个队列用FCFS算法。

2.在实际情况中，短作业进程占有很大的比例。SFJ以作业的长短计算优先级，作业越短，优先级越高。从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先调度。

##### 优先级调度算法（PSA）和高响应比优先调度算法（HRRN）

1.基于作业的紧迫程度，赋予作业相应的优先级。

2.考虑作业的等待时间以及作业运行时间的调度算法。根据等待时间和作业运行时间设置**动态优先级**，令其随着等待时间延长而增加，等到足够的时间必然有机会获得处理机。

##### 进程调度机制

进程调度的任务有三：1.保存处理机现场信息 2.按某种算法选取进程 3.把处理器分配给线程

进程调度机制：维护一个队列-->将进程从队列中取出 即分派进程-->上下文切换

进程调度方式：1.非抢占式：阻塞中断才考虑切换；2.抢占方式： 根据若干原则抢占处理机。

#####  轮转调度算法

让就绪队列的每个进程每次只运行一个时间片。轮转法（**RR**）中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，设置一个时间间隔产生一次中断，完成一次调度，将CPU分配给队首进程，若上一个进程没结束将之放在队尾。

比较关键的是**时间片大小的确定**：应略大于一次典型交互所需要的时间，使得交互式进程能在一个时间片内完成，从而获得很小的响应时间。

##### 多级反馈队列调度算法

1.设置多个就绪队列，第一个优先级最高，第二个次之，其余递减。

2.每个队列采取FCFS算法，若在该时间片内完成则撤离系统，若没有完成则放在下一个队列的队尾等候。

3.按照队列优先级调度。首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，当且仅当在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。

#### 死锁

##### 产生死锁的必要条件 

四个条件都必须满足：1.互斥；2.请求和保持条件，就是抓住自己获得的资源保持不放 3.不可抢占原则，资源只有在进程使用完之后自己释放 4.循环等待条件，必然存在一个进程-资源的循环链。

**处理死锁**的方法：预防 避免 检测 解除

##### 预防死锁

破坏产生死锁的四个条件中的一个或者几个。由于互斥是必然发生的，因此只能从后面的三个下手。

###### 破坏“请求和保持”条件

第一种协议：是之前说过的，要么全给要么不给的思路。这种协议的有点简单，易行且安全。但是会出现资源被严重浪费，使得进程经常会发生饥饿现象。

第二种协议：是对第一种协议的改进，它允许一个线程只获得运行初期的资源后就开始运行，运行的过程中再主键释放已经分配给自己的，且已经用完的资源，然后请求新的资源。

###### 破坏“不可抢占”条件

该协议规定，当一个进程取得了某些资源，又提出新的资源请求而又不能得到满足时，它必须释放已经保持的所有资源，在以后需要的时候重新申请。

实现起来比较复杂，且需要比较高的代价。会使得前一阶段的工作的失效，延长了进程的周转时间，增加了系统开销，降低了系统吞吐量。

###### 破环“循环等待”条件

对系统内的所有资源进行线性排序，并赋予不同的序号。然后采用这样的预防协议：规定每个进程必须按照序号递增的顺序请求资源。再采用这样的策略形成的资源分配图中，不可能出现环路，因而破坏了”循环等待“的条件。

缺点是需要保证系统的各类资源线性排序相对稳定，这就限制了新类型设备的增加；编号时需要考虑作业实际使用这些资源的顺序，否则会造成资源的浪费。

##### 避免死锁

把系统的状态分为安全状态和不安全状态，处于不安全状态时有可能进入死锁。

**银行家算法避免死锁**  四个数据结构分别描述系统可用资源，所有进程对A资源的最大需求，系统的资源分配，进程还需要多少资源。

算法思想：经过初步检查现有资源可以分配给某个线程，然后试探者将资源分配给该线程，修改上述的四个结构，然后执行**安全性算法**。安全性算法实质也是尝试，试着把Available资源分配给线程，若能够满足该线程所需，则该线程可以顺利完成，标记线程为true，回收所有资源，然后尝试下一个，若所有的线程最后都被标记为true则系统安全。可参考博文如下：

> https://www.cnblogs.com/chuxiuhong/p/6103928.html

##### 死锁的检测与解除

###### 死锁状态检测

操作系统不断监视系统进展情况，判断死锁是否发生。一旦死锁发生则采取专门的措施，解除死锁并以最小代价恢复系统运行。其中检测死锁用到了资源分配图：


​	用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。



让某个进程先获得所需的所有资源，同时意味着其他线程让出资源，直至该线程完成之后释放资源，成为一个孤立节点，消去所有的边，以此反复，若能消去所有的边，使所有的进程节点都成为孤立节点，则称该图是可完全简化的，否则是不可完全简化的，且判断为死锁状态。

###### 死锁的解除

一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。死锁解除的主要方法有：

1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。

2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。

3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

> https://blog.csdn.net/jgm20475/article/details/81297819

### 第四章  存储器管理

#### 存储器的层次结构

##### 多层结构的存储器系统

###### 存储器的多层结构

存储层次至少应该有三级：最高层是CPU寄存器，中间为主存，最底层为辅存。还可以根据具体的功能分为寄存器，高速缓存，主存储器，磁盘缓存，固定磁盘，可移动磁盘。越靠近CPU，存储介质访问速度越快，价格越高。

###### 可执行存储器

寄存器和主存储器又被称为可执行存储器，进程可以再很短的时钟周期内使用一条load/store语句对可执行存储器进行访问，而辅存是要通过I/O操作访问。

###### 主存储器和寄存器

主存储器又被称为内存或者主存，通常处理机都是从主存中取得指令和数据的，并将其所获得的指令/数据放在指令/数据寄存器中，或者反之。

寄存器的访问速度最快，完全能与CPU协调工作。

###### 高速缓存和磁盘缓存

  介于寄存器和存储器之间的存储器，主要用于备份主存中较为常用的数据，以减少处理机对主存的访问次数，这里也引入了数据的有效性问题。

###### 磁盘缓存

为了缓和主存和磁盘的访问速度的不一致，设置了磁盘缓存，再主存中暂时存放的一部分磁盘数据和信息，减少访问磁盘的次数。磁盘缓存与高速缓存不同，不是一种实际存在的存储器，而是利用了主存中部分存储空间。

以上的寄存器，高速缓存，主存，磁盘缓存都是操作系统直接管辖，掉电之后存储的信息将不再存在。

